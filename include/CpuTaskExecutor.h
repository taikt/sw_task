/**
 * @file CpuTaskExecutor.h
 * @brief CPU-bound task executor with async execution and timeout support
 * @author Tran Anh Tai
 * @date 9/2025
 * @version 1.0.0
 */

 #pragma once

 #include <future>
 #include <chrono>
 #include <functional>
 #include <stdexcept>
 #include <type_traits>
 
 // Forward declarations only
 namespace swt {
     class SLLooper;
     template<typename T> class Promise;
 }
 
 namespace swt {
 
 /**
  * @class CpuTaskTimeoutException
  * @brief Exception thrown when CPU-bound tasks exceed timeout limits
  * 
  * This exception is thrown by \ref swt::CpuTaskExecutor "CpuTaskExecutor" when a CPU-intensive task
  * doesn't complete within the specified timeout duration. Provides
  * detailed timeout information for debugging and error handling.
  * 
  * The exception is generated by the timeout management system and
  * delivered through the \ref swt::Promise "Promise" mechanism to maintain thread safety
  * and consistent error handling patterns.
  * 
  * @code{.cpp}
  * promise.catch_error(looper, [](std::exception_ptr ex) {
  *     try {
  *         std::rethrow_exception(ex);
  *     } catch (const CpuTaskTimeoutException& timeout) {
  *         std::cerr << "Task timed out: " << timeout.what() << std::endl;
  *         // Handle timeout-specific recovery
  *     } catch (const std::exception& other) {
  *         std::cerr << "Other error: " << other.what() << std::endl;
  *     }
  * });
  * @endcode
  * 
  * @note Inherits from std::runtime_error for standard exception handling
  * @note Contains timeout duration information in error message
  * 
  * @see \ref swt::CpuTaskExecutor::executeAsync "CpuTaskExecutor::executeAsync", \ref swt::Promise::catch_error "Promise::catch_error"
  */
 class CpuTaskTimeoutException : public std::runtime_error {
 public:
     /**
      * @brief Constructor with timeout message
      * @param message Descriptive message including timeout duration
      * 
      * Creates a timeout exception with detailed information about
      * the timeout duration and context for debugging purposes.
      * 
      * @code{.cpp}
      * // Typical usage (internal to CpuTaskExecutor)
      * throw CpuTaskTimeoutException("CPU task timeout after 5000ms");
      * @endcode
      */
     explicit CpuTaskTimeoutException(const std::string& message) 
         : std::runtime_error(message) {}
 };
 
 /**
  * @class CpuTaskExecutor
  * @brief Static utility class for executing CPU-intensive tasks asynchronously
  * 
  * CpuTaskExecutor provides a high-level interface for executing CPU-bound tasks
  * in separate threads while integrating seamlessly with the event loop pattern.
  * Key features include:
  * 
  * - **Async execution**: Uses std::async for guaranteed separate thread execution
  * - **Event loop integration**: Results delivered via \ref swt::SLLooper "SLLooper" for thread safety
  * - **Timeout support**: Optional timeout protection against runaway computations
  * - **Exception safety**: Comprehensive exception capture and propagation
  * - **Type safety**: Template-based with automatic type deduction
  * - **Promise integration**: Returns \ref swt::Promise "Promise" objects for continuation chaining
  * 
  * Architecture:
  * - **Static methods**: No instance state, pure utility class design
  * - **Template-based**: Supports any callable with automatic return type deduction
  * - **Thread separation**: CPU tasks execute in dedicated threads
  * - **Result posting**: Thread-safe result delivery via event loop
  * - **Fire-and-forget**: std::future used internally but Promise provides coordination
  * 
  * Use cases:
  * - **Mathematical computations**: Fibonacci, prime numbers, matrix operations
  * - **Data processing**: Large file processing, image manipulation
  * - **Cryptographic operations**: Encryption, hashing, key generation
  * - **Network operations**: HTTP requests, DNS lookups (with timeout)
  * - **File I/O**: Large file operations that might block
  * 
  * @code{.cpp}
  * // Simple CPU-bound task without timeout
  * auto promise1 = CpuTaskExecutor::executeAsync(looper, []() {
  *     return fibonacci(45);  // Long-running computation
  * });
  * 
  * // CPU-bound task with 5-second timeout protection
  * auto promise2 = CpuTaskExecutor::executeAsync(looper, []() {
  *     return processLargeDataset(data);
  * }, 5000ms);
  * 
  * // Chain results with error handling
  * promise2.then(looper, [](auto result) {
  *     std::cout << "Processing completed: " << result << std::endl;
  * }).catch_error(looper, [](std::exception_ptr ex) {
  *     // Handle both timeout and function exceptions
  * });
  * @endcode
  * 
  * @note All methods are static - no instance creation required
  * @note Functions execute in separate threads - ensure thread safety
  * @note Results are posted back to specified SLLooper thread
  * @warning Avoid capturing event loop objects in task functions
  * 
  * @see \ref swt::Promise "Promise", \ref swt::SLLooper "SLLooper", \ref swt::CpuTaskTimeoutException "CpuTaskTimeoutException"
  */
 class CpuTaskExecutor {
 public:
     /**
      * @brief Execute CPU-bound task asynchronously without timeout
      * @tparam Func Function type (auto-deduced)
      * @param resultLooper SLLooper instance for result callback execution
      * @param func CPU-intensive function to execute
      * @return Promise<ReturnType> Promise for result retrieval and chaining
      * 
      * Executes CPU-intensive tasks in a separate thread without timeout limits.
      * This is the preferred method for tasks with predictable execution times
      * or when timeout protection is handled at a higher level.
      * 
      * Key characteristics:
      * - **No timeout limit**: Task runs until completion or exception
      * - **Separate thread**: Guaranteed execution in dedicated thread
      * - **Exception safety**: All exceptions captured and propagated via Promise
      * - **Type deduction**: Return type automatically deduced from function
      * - **Move semantics**: Efficient parameter transfer to execution thread
      * 
      * Execution flow:
      * 1. Create Promise for result coordination
      * 2. Launch std::async task with std::launch::async policy
      * 3. Execute function in separate thread
      * 4. Capture result or exception
      * 5. Post result back to SLLooper thread
      * 6. Resolve Promise in event loop context
      * 
      * @code{.cpp}
      * // Mathematical computation
      * auto fibPromise = CpuTaskExecutor::executeAsync(looper, []() {
      *     return fibonacci(45);
      * });
      * 
      * // Data processing with parameters
      * std::vector<int> data = getData();
      * auto processPromise = CpuTaskExecutor::executeAsync(looper, 
      *     [data = std::move(data)]() {
      *         return processData(data);
      *     });
      * 
      * // Void-returning task
      * auto voidPromise = CpuTaskExecutor::executeAsync(looper, []() {
      *     performSideEffect();  // No return value
      * });
      * @endcode
      * 
      * @note Implementation in CpuTaskExecutor.tpp
      * @note Function parameter passed by universal reference for efficiency
      * @note SLLooper parameter passed by value for safe capture
      * @note Supports both value-returning and void functions
      * @see \ref swt::CpuTaskExecutor::executeAsync "executeAsync(Func&&)", \ref swt::Promise "Promise"
      */
     template<typename Func>
     static auto executeAsync(std::shared_ptr<SLLooper> resultLooper,
                            Func&& func) 
         -> Promise<decltype(func())>;
     
     /**
      * @brief Execute CPU-bound task asynchronously with timeout protection
      * @tparam Func Function type (auto-deduced)
      * @param resultLooper SLLooper instance for result callback execution
      * @param func CPU-intensive function to execute
      * @param timeout Maximum execution time before timeout exception
      * @return Promise<ReturnType> Promise for result retrieval and chaining
      * 
      * Executes CPU-intensive tasks with timeout protection to prevent runaway
      * computations from hanging the application. Uses a two-level async approach
      * for precise timeout detection while maintaining the same Promise-based
      * result delivery mechanism.
      * 
      * Key characteristics:
      * - **Timeout protection**: CpuTaskTimeoutException after timeout period
      * - **Precise timing**: Uses std::future::wait_for for accurate timeout detection
      * - **Two-level async**: Outer timeout management, inner task execution
      * - **Exception discrimination**: Separates timeout from function exceptions
      * - **Resource handling**: Background cleanup of timed-out tasks
      * 
      * Timeout behavior:
      * - **Success case**: Normal result delivery if completed within timeout
      * - **Timeout case**: CpuTaskTimeoutException delivered via Promise
      * - **Exception case**: Function exceptions delivered normally via Promise
      * - **Background cleanup**: Timed-out tasks continue but results discarded
      * 
      * @code{.cpp}
      * // Network operation with 10-second timeout
      * auto networkPromise = CpuTaskExecutor::executeAsync(looper, []() {
      *     return downloadLargeFile(url);
      * }, 10000ms);
      * 
      * // Mathematical computation with 5-second timeout
      * auto mathPromise = CpuTaskExecutor::executeAsync(looper, []() {
      *     return complexCalculation();
      * }, 5000ms);
      * 
      * // Handle timeout vs normal exceptions
      * mathPromise.catch_error(looper, [](std::exception_ptr ex) {
      *     try {
      *         std::rethrow_exception(ex);
      *     } catch (const CpuTaskTimeoutException& timeout) {
      *         // Specific timeout handling
      *         std::cerr << "Operation timed out!" << std::endl;
      *     } catch (const std::exception& other) {
      *         // Other computation errors
      *         std::cerr << "Computation error: " << other.what() << std::endl;
      *     }
      * });
      * @endcode
      * 
      * @note Implementation in CpuTaskExecutor.tpp
      * @note Timeout resolution limited by std::future::wait_for precision
      * @note Timed-out tasks may continue running but results are discarded
      * @note Timeout duration included in CpuTaskTimeoutException message
      * @warning Long-running tasks cannot be forcibly terminated after timeout
      * @see \ref swt::CpuTaskTimeoutException "CpuTaskTimeoutException", \ref swt::Promise "Promise"
      */
     template<typename Func>
     static auto executeAsync(std::shared_ptr<SLLooper> resultLooper,
                            Func&& func,
                            std::chrono::milliseconds timeout) 
         -> Promise<decltype(func())>;
 
 private:
     /**
      * @brief Private constructor - static-only utility class
      * 
      * CpuTaskExecutor is designed as a pure utility class with only
      * static methods. No instance creation is needed or allowed.
      */
     CpuTaskExecutor() = delete;
     
     /**
      * @brief Deleted copy constructor - static-only utility class
      */
     CpuTaskExecutor(const CpuTaskExecutor&) = delete;
     
     /**
      * @brief Deleted assignment operator - static-only utility class
      */
     CpuTaskExecutor& operator=(const CpuTaskExecutor&) = delete;
 };
 
 } // namespace swt
 
 // Include template implementations
 #include "CpuTaskExecutor.tpp"