


@startuml

rectangle "Client Application" as Client 
rectangle "epoll + timerfd" as EpollFd <<Linux Kernel>>

package "SW Task Framework" #LightYellow {
    
    package "Main Thread Event Loop" {
        rectangle "SLLooper" as Looper
        rectangle "EventQueue" as Queue
        rectangle "QueueItem" as QueueItem
    }
    
    package "Message System" #LightBlue {
        rectangle "Handler" as Handler
        rectangle "Message" as Message
    }
    
    package "Timer System" #LightGreen {
        rectangle "TimerManager" as TimerMgr
        rectangle "Timer" as Timer
    }
    
    package "CPU-bound Task Execution" #Orange {
        rectangle "CpuTaskExecutor" as CpuExec
        rectangle "CPUTaskThread" as AsyncWorker <<Thread>>
    }
    
    package "Async Helper" #Pink {
        
        package "Promise System" #LightCyan {
            rectangle "Promise<T>" as PromiseMgr
            rectangle "State<T>" as StateMgr
        }
        
        package "Coroutines System" #LightSalmon {
            rectangle "Task<T>" as TaskMgr
            rectangle "WorkAwaitable<T>" as WorkAwaitable
            rectangle "PostAwaitable<T>" as PostAwaitable
            rectangle "DelayAwaitable" as DelayAwaitable
        }
    }
}

' Pure "uses" dependencies only
Client ..> Looper : uses
Client ..> Handler : uses
Client ..> PromiseMgr : uses
Client ..> TaskMgr : uses

Looper ..> Queue : uses
Looper ..> TimerMgr : uses
Looper ..> CpuExec : uses

Queue ..> QueueItem : uses

QueueItem ..> Message : uses

Handler ..> Message : uses
Handler ..> Queue : uses

TimerMgr ..> Timer : uses
TimerMgr ..> EpollFd : uses

CpuExec ..> PromiseMgr : uses
CpuExec ..> AsyncWorker : uses

' Promise System dependencies
PromiseMgr ..> StateMgr : uses
StateMgr ..> Queue : uses

' co_await System dependencies
TaskMgr ..> WorkAwaitable : uses
TaskMgr ..> PostAwaitable : uses
TaskMgr ..> DelayAwaitable : uses
WorkAwaitable ..> Looper : uses
PostAwaitable ..> Looper : uses
DelayAwaitable ..> TimerMgr : uses

@enduml


' C&C data flow diagram
@startuml
!define COMPONENT rectangle

COMPONENT [Client Application] as Client 
' COMPONENT [epoll + timerfd] as EpollFd <<Linux Kernel>>

package "SW Task Framework" #LightBlue {
    
    package "Main Thread Event Loop" {
        COMPONENT [SLLooper] as Looper <<Facade>>
        COMPONENT [EventQueue] as Queue <<Queue>>
        COMPONENT [QueueItem] as QueueItem <<Union Type>>
    }
    
    package "Message System" #LightYellow {
        COMPONENT [Handler] as Handler <<Abstract>>
        COMPONENT [Message] as Message <<Data>>
    }
    
    package "Timer System" #LightGreen {
        COMPONENT [TimerManager] as TimerMgr <<Manager>>
        COMPONENT [Timer] as Timer <<RAII>>
    }
    
    package "CPU-bound Task Execution" #Orange {
        COMPONENT [CpuTaskExecutor] as CpuExec <<Static Methods>>
        COMPONENT [CPUTaskThread] as AsyncWorker <<Thread>>
    }
    
    package "Async Helper" #Pink {
        
        package "Promise System" #LightCyan {
            COMPONENT [Promise<T>] as PromiseMgr <<Template>>
            COMPONENT [State<T>] as StateMgr <<Template>>
        }
        
        package "Coroutines System" #LightSalmon {
            COMPONENT [Task<T>] as TaskMgr <<Coroutine>>
            COMPONENT [WorkAwaitable<T>] as WorkAwaitable <<Awaitable>>
            COMPONENT [PostAwaitable<T>] as PostAwaitable <<Awaitable>>
            COMPONENT [DelayAwaitable] as DelayAwaitable <<Awaitable>>
        }
    }
}

' Main flow connections
Client --> Looper : post() / postWork() / co_await
Client --> Handler : sendMessage()
Client --> TaskMgr : create Task<T>
Looper --> Queue : enqueue QueueItem
Queue --> Looper : poll QueueItem
Looper --> Client : execute callbacks

' QueueItem relationships
Queue --> QueueItem : contains
QueueItem --> Message : holds Message
QueueItem --> PromiseMgr : holds packaged_task
QueueItem --> WorkAwaitable : holds coroutine_handle

' Message system flow
Handler --> Message : obtainMessage()
Handler --> Queue : sendMessage()
Queue --> Handler : dispatchMessage()

' CPU task flow (Promise System)
Looper --> CpuExec : postWork(heavyTask)
CpuExec --> PromiseMgr : create Promise<T>
PromiseMgr --> StateMgr : contains State<T>
CpuExec --> AsyncWorker : std::async(task)
AsyncWorker --> StateMgr : setValue(result)
StateMgr --> Queue : post continuation

' Coroutines flow
Looper --> WorkAwaitable : awaitWork(func)
Looper --> PostAwaitable : awaitPost(func)
Looper --> DelayAwaitable : awaitDelay(ms)
WorkAwaitable --> AsyncWorker : execute on background
PostAwaitable --> Queue : execute on main thread
DelayAwaitable --> TimerMgr : schedule delay

' Timer flow
Client --> Looper : addTimer()
Looper --> TimerMgr : createTimer()
TimerMgr --> Timer : return RAII object
' TimerMgr --> EpollFd : timerfd_create/epoll_wait
' EpollFd --> TimerMgr : timer expiration events
TimerMgr --> Queue : post timer callbacks

' Promise chaining
PromiseMgr --> PromiseMgr : .then() / .catchError()

' ' Coroutine relationships
' TaskMgr --> WorkAwaitable : manages awaitable lifecycle
' TaskMgr --> PostAwaitable : manages awaitable lifecycle
' TaskMgr --> DelayAwaitable : manages awaitable lifecycle

' ' Awaitable completion flow
' WorkAwaitable --> TaskMgr : resume coroutine
' PostAwaitable --> TaskMgr : resume coroutine
' DelayAwaitable --> TaskMgr : resume coroutine

' Legend
' legend right
'     | --> | Data/Control flow |
'     | <<Union Type>> | Can hold different types |
'     | <<Linux Kernel>> | OS integration |
'     | <<RAII>> | Resource management |
'     | <<Template>> | Generic programming |
'     | <<Coroutine>> | C++20 coroutine wrapper |
'     | <<Awaitable>> | C++20 awaitable types |
' endlegend


@enduml