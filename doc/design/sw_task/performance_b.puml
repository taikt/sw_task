


@startuml

rectangle "Client Application" as Client

package "SW Task Framework" #LightBlue {
    
    package "Async Helper" #Pink {
        
        package "Promise" #LightYellow {
            rectangle "Promise<T>" as PromiseMgr
            rectangle "State<T>" as StateMgr
            rectangle "Promise<void>" as PromiseVoid <<specialization>>
            rectangle "State<std::monostate>" as StateMono <<specialization>>
        }
        
        package "Coroutines" #LightGreen {
            rectangle "Task<T>" as TaskMgr
            rectangle "WorkAwaitable<T>" as WorkAwaitable
            rectangle "PostAwaitable<T>" as PostAwaitable
            rectangle "DelayAwaitable" as DelayAwaitable
            rectangle "WorkAwaitable<void>" as WorkAwaitableVoid <<specialization>>
            rectangle "PostAwaitable<void>" as PostAwaitableVoid <<specialization>>
        }
    }

    package "Main Thread Event Loop" {
        rectangle "SLLooper" as Looper
        rectangle "EventQueue" as Queue
    }
}

' External relationships - uses dependency only
Client ..> Looper : uses
Client ..> PromiseMgr : uses
Client ..> TaskMgr : uses

' Internal framework relationships - uses dependency only
Looper ..> Queue : uses
Queue ..> PromiseMgr : uses
Queue ..> WorkAwaitable : uses
Queue ..> PostAwaitable : uses

' Promise System internal relationships
PromiseMgr ..> StateMgr : uses
PromiseVoid ..> PromiseMgr : uses
StateMono ..> StateMgr : uses

' Co_Await System internal relationships
TaskMgr ..> WorkAwaitable : uses
TaskMgr ..> PostAwaitable : uses
TaskMgr ..> DelayAwaitable : uses
WorkAwaitable ..> Looper : uses
PostAwaitable ..> Looper : uses
DelayAwaitable ..> Looper : uses
WorkAwaitableVoid ..> WorkAwaitable : uses
PostAwaitableVoid ..> PostAwaitable : uses

@enduml








@startuml
'title "SW Task Framework - Promise Creation & Chaining Setup"

autonumber

participant "Client Application" as Client

box "SW Task Framework" #LightBlue
    participant "SLLooper\n(Event Loop)" as Looper
    participant "EventQueue" as MQ
    participant "Promise<T>" as Promise
    participant "State<T>" as State
end box

== Promise Creation Phase ==
Client -> Looper : createPromise<T>()
activate Looper

Looper -> MQ : enqueuePromise<T>()
activate MQ

MQ -> Promise : new Promise<T>()
activate Promise

Promise -> State : new State<T>()
activate State
note right of State : Initialize:\n- result = nullopt\n- exception = nullptr\n- continuation = nullptr
State --> Promise : return
deactivate State

Promise --> MQ : return Promise<T>
deactivate Promise

MQ --> Looper : return Promise<T>
deactivate MQ

Looper --> Client : return Promise<T>
deactivate Looper

== Promise Chaining Setup ==
Client -> Promise : then<U>(continuation_func)
activate Promise
Promise -> State : setContinuation(continuation_func)
activate State
State --> Promise : void
deactivate State
Promise --> Client : return Promise<U>
deactivate Promise

Client -> Promise : catch_error(error_handler)
activate Promise
Promise -> State : setErrorHandler(error_handler)
activate State
State --> Promise : void
deactivate State
Promise --> Client : return this Promise<T>
deactivate Promise

note over Client, State : Promise chain is now configured\nand ready for async execution

@enduml


@startuml
'title "SW Task Framework - Async Execution & Event Loop Processing"

autonumber

participant "Client Application" as Client

box "SW Task Framework" #LightBlue
    participant "SLLooper\n(Event Loop)" as Looper
    participant "EventQueue" as MQ
    participant "Promise<T>" as Promise
    participant "State<T>" as State
end box

== Async Execution & Resolution ==
note over Client : External async operation completes
Client ->> State : setValue(result) or setException(error)
activate State
'note right of State : Async call - non-blocking

State ->> Looper : post continuation/error handler to event loop
note right of Looper : Posted to internal event loop

== Event Loop Processing ==
Looper -> MQ : pollNext()
activate MQ
MQ --> Looper : return ready QueueItem
deactivate MQ

alt Normal Result Case
    Looper -> State : executeContinuation(result)
    activate State
    State -> Client : invoke then() callback with result
    activate Client
    note right of Client : Callback execution
    Client --> State : processing complete
    deactivate Client
    State --> Looper : execution complete
    deactivate State
else Exception Case
    Looper -> State : executeErrorHandler(exception)
    activate State
    State -> Client : invoke catch_error() callback
    activate Client
    note right of Client : Error handling
    Client --> State : error handled
    deactivate Client
    State --> Looper : error handling complete
    deactivate State
end

deactivate State

note over Promise : Promise chain continues\nwith next then() or catch_error()

@enduml



@startuml
'title "SW Task Framework - Promise Creation and Execution Flow"

rectangle "Client\nApplication" as Client

package "SW Task Framework" #LightBlue {
    
    package "Main Thread" {
        rectangle "SLLooper" as Looper
        rectangle "EventQueue" as MQ
        rectangle "Main Thread Event Loop" as MainLoop <<EventLoop>>
    }
    
    package "Async Helper" {
        rectangle "Promise" as Promise
        rectangle "State" as State
    }
}

' Promise Creation and Setup Flow
Client --> Looper : "1: createPromise()"
Looper --> MQ : "2: enqueuePromise()"
MQ --> Promise : "3: new Promise()"
Promise --> State : "4: new State()"

' Promise Chaining Setup
Client --> Promise : "5: then(), catch_error()"
Promise --> State : "6: setContinuation(), setErrorHandler()"

' Async Execution Flow
Client --> State : "7: setValue/setException (async)"
State --> MainLoop : "8: post continuation/error handler"
MainLoop --> MQ : "9: schedule execution"
MQ --> MainLoop : "10: pollNext()"
MainLoop --> State : "11: executeContinuation/executeErrorHandler()"
State --> Client : "12: invoke callbacks"

@enduml


@startuml
'title "SW Task Framework - co_await Creation and Execution Flow"

rectangle "ClientApplication" as Client

package "SW Task Framework" #LightBlue {
    
    package "Main Thread" {
        rectangle "SLLooper" as Looper
        rectangle "EventQueue" as MQ
        rectangle "Main Thread Event Loop" as MainLoop
    }
    
    package "Async Helper" {
        rectangle "Task<T>" as Task
        rectangle "PostAwaitable<T>" as Awaitable
    }
}

' co_await Creation and Setup Flow
Client --> Looper : "1: awaitPost"
Looper --> Awaitable : "2: new PostAwaitable<T>()"
Awaitable --> Task : "3: create awaitable wrapper"
Task --> Client : "4: return PostAwaitable<T>"

' co_await Suspension Flow
Client --> Awaitable : "5: co_await"
Awaitable --> Client : "6: return false (not ready)"
Client --> Awaitable : "7: await_suspend"
Awaitable --> Looper : "8: post"

' Async Execution Flow
Looper --> MQ : "9: enqueue(task)"
MQ --> MainLoop : "10: schedule execution"
MainLoop --> MQ : "11: pollNext()"
MainLoop --> Client : "12: execute user function"
Client --> MainLoop : "13: return result"
MainLoop --> Awaitable : "14: setResult(value)"

' Coroutine Resume Flow
Awaitable --> MainLoop : "15: resume(coroutine_handle)"
MainLoop --> Client : "16: resume coroutine execution"
Client --> Awaitable : "17: await_resume()"
Awaitable --> Client : "18: return result"

@enduml


@startuml
'title "SW Task Framework - co_await Execution Flow (coawait_simple.cpp)"

autonumber

participant "Client Application" as Client

box "SW Task Framework" #LightBlue
    participant "SLLooper" as Looper
    participant "EventQueue" as MQ
    participant "PostAwaitable" as Awaitable
    participant "Event Loop Thread" as EventThread
end box

== co_await awaitPost Execution ==
Client -> Looper : awaitPost(fetchData)
activate Looper

Looper -> Awaitable : new PostAwaitable<int>(looper, fetchData)
activate Awaitable
Awaitable --> Looper : return PostAwaitable<int>

Looper --> Client : return PostAwaitable<int>
deactivate Looper

Client -> Awaitable : co_await (await_ready())
activate Awaitable
Awaitable --> Client : return false
note right of Awaitable : Not ready, need suspension

Client -> Awaitable : await_suspend(coroutine_handle)
note right of Client : **SUSPEND POINT**\nSync call to suspend

Awaitable -> Looper : post(lambda_wrapper)
activate Looper
note right of Looper : Sync call to post task

Looper -> MQ : enqueue(lambda_wrapper)
activate MQ
MQ --> Looper : queued
deactivate MQ

Looper --> Awaitable : posted
deactivate Looper

Awaitable --> Client : suspended
deactivate Awaitable
note right of Client : **COROUTINE SUSPENDED**\nWaiting for completion

== Event Loop Thread Execution ==
activate MQ
MQ ->> EventThread : execute_queued_task()
activate EventThread
note right of EventThread : **Async execution**\nOn background thread

EventThread -> Client : fetchData()
activate Client
note right of Client : User function execution

Client --> EventThread : return 123
deactivate Client

EventThread -> Awaitable : setResult(123)
activate Awaitable
Awaitable --> EventThread : stored
deactivate Awaitable

EventThread ->> Client : resume(coroutine_handle)
note right of Client : **RESUME POINT**\nAsync callback to resume
deactivate EventThread
deactivate MQ

== Client Coroutine Completion ==
activate Client
note right of Client : **COROUTINE RESUMED**\nContinue from suspend point

Client -> Awaitable : await_resume()
activate Awaitable
Awaitable --> Client : return result
deactivate Awaitable

Client -> Client : "Result from awaitPost: 123"
deactivate Client

@enduml